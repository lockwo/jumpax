{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Jumpax","text":"<p>Jumpax is a JAX-based library providing numerical jump process solvers.</p> <p>Heavily adapted/inspired by JumpProcesses.jl and diffrax.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>git clone https://github.com/lockwo/jumpax.git\ncd jumpax\npip install -e .\n</code></pre> <p>Requires Python &gt;= 3.10</p>"},{"location":"#quick-example","title":"Quick example","text":"<p>Simulate a simple birth-death process:</p> <pre><code>import jax.numpy as jnp\nimport jumpax as jpx\n\n# Reactant stoichiometry: birth needs 0, death needs 1\nreactants = jnp.array([[0], [1]])\n# Net stoichiometry: birth adds 1, death removes 1\nnet_stoich = jnp.array([[1], [-1]])\n# Rate constants\nrates = jnp.array([10.0, 0.1])\n\njumps = jpx.MassActionJump(reactants, net_stoich, rates=rates)\nsolver = jpx.SSA()\nsave = jpx.Save(states=True)\n\nu0 = jnp.array([50.0]) # initial population\nkey = jax.random.key(0)\n\nsol = jpx.solve(jumps, solver, save, u0, t0=0.0, t1=1.0, key=key)\nmask = jnp.isfinite(sol.ts)\nts, us = sol.ts[mask], sol.us[mask]\n\nprint(f\"Final population: {us[-1]}\")\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you found this library useful in academic research, please cite: </p> <pre><code>@software{lockwood2025jumpax,\n  title = {jumpax: Jump Processes in JAX},\n  author = {Owen Lockwood},\n  url = {https://github.com/lockwo/jumpax},\n  doi = {},\n}\n</code></pre> <p>(Also consider starring the project on GitHub.)</p>"},{"location":"#see-also-other-libraries-in-the-jax-ecosystem","title":"See also: other libraries in the JAX ecosystem","text":"<p>Awesome JAX: a longer list of other JAX projects.  </p>"},{"location":"api/aggregators/","title":"Aggregators","text":"<p>Aggregators implement the stepping logic for simulating jump processes.</p>"},{"location":"api/aggregators/#abstract-base-classes","title":"Abstract Base Classes","text":""},{"location":"api/aggregators/#jumpax.AbstractAggregator","title":"<code>jumpax.AbstractAggregator</code> <code></code>","text":"<p>Abstract base class for all aggregators (solvers).</p> <p>Aggregators implement the stepping logic for jump processes, determining when jumps occur and which reaction(s) fire(s).</p>"},{"location":"api/aggregators/#jumpax.AbstractAggregator.init","title":"<code>init(jumps, u0: Shaped[Array, '?*u'], args: PyTree[Any], key: Key[Array, '']) -&gt; ~_SolverState</code>","text":"<p>Initialize solver-specific state.</p> <p>Arguments:</p> <ul> <li><code>jumps</code>: the jump problem</li> <li><code>u0</code>: initial state</li> <li><code>args</code>: static arguments</li> <li><code>key</code>: random key</li> </ul> <p>Returns:</p> <p>Initial solver state for this aggregator.</p>"},{"location":"api/aggregators/#jumpax.AbstractAggregator.step","title":"<code>step(jumps, t: Real[ArrayLike, ''], u: Shaped[Array, '?*u'], args: PyTree[Any], key: Key[Array, ''], t1: Real[ArrayLike, ''], jump_state: PyTree[Any], solver_state: ~_SolverState) -&gt; tuple</code>","text":"<p>Advance one step of the simulation.</p> <p>Arguments:</p> <ul> <li><code>jumps</code>: the jump problem</li> <li><code>t</code>: current time</li> <li><code>u</code>: current state</li> <li><code>args</code>: static arguments</li> <li><code>key</code>: random key</li> <li><code>t1</code>: end time (step will not exceed this)</li> <li><code>jump_state</code>: current jump state</li> <li><code>solver_state</code>: current solver state</li> </ul> <p>Returns:</p> <p>A tuple <code>(u_new, t_next, made_jump, jump_index, jump_state_new, solver_state_new, info)</code> , if <code>made_jump</code> is False then <code>u_new == u</code> and <code>jump_index == -1</code>.</p>"},{"location":"api/aggregators/#jumpax.AbstractHybridAggregator","title":"<code>jumpax.AbstractHybridAggregator(jumpax.AbstractAggregator)</code> <code></code>","text":"<p>Abstract base class for hybrid aggregators that combine diffrax integration with jumps.</p>"},{"location":"api/aggregators/#jumpax.AbstractHybridAggregator.init","title":"<code>init(jumps, u0: Shaped[Array, '?*u'], args: PyTree[Any], key: Key[Array, '']) -&gt; ~_SolverState</code>","text":"<p>Initialize solver-specific state.</p> <p>Arguments:</p> <ul> <li><code>jumps</code>: the jump problem</li> <li><code>u0</code>: initial state</li> <li><code>args</code>: static arguments</li> <li><code>key</code>: random key</li> </ul> <p>Returns:</p> <p>Initial solver state for this aggregator.</p>"},{"location":"api/aggregators/#jumpax.AbstractHybridAggregator.step","title":"<code>step(jumps, t: Real[ArrayLike, ''], u: Shaped[Array, '?*u'], args: PyTree[Any], key: Key[Array, ''], t1: Real[ArrayLike, ''], jump_state: PyTree[Any], solver_state: ~_SolverState) -&gt; tuple</code>","text":"<p>Advance one step of the simulation.</p> <p>Arguments:</p> <ul> <li><code>jumps</code>: the jump problem</li> <li><code>t</code>: current time</li> <li><code>u</code>: current state</li> <li><code>args</code>: static arguments</li> <li><code>key</code>: random key</li> <li><code>t1</code>: end time (step will not exceed this)</li> <li><code>jump_state</code>: current jump state</li> <li><code>solver_state</code>: current solver state</li> </ul> <p>Returns:</p> <p>A tuple <code>(u_new, t_next, made_jump, jump_index, jump_state_new, solver_state_new, info)</code> , if <code>made_jump</code> is False then <code>u_new == u</code> and <code>jump_index == -1</code>.</p>"},{"location":"api/aggregators/#pure-jump-aggregators","title":"Pure Jump Aggregators","text":""},{"location":"api/aggregators/#jumpax.SSA","title":"<code>jumpax.SSA(jumpax.AbstractAggregator)</code> <code></code>","text":"<p>Stochastic Simulation Algorithm (Gillespie's direct method).</p> <p>Samples the next reaction time \\(\\tau\\) from an exponential distribution with rate \\(a_0 = \\sum_j a_j(u)\\), where \\(a_j(u)\\) is the propensity of reaction \\(j\\). The reaction channel is selected proportionally to its rate.</p> <p>This is an exact method for simulating continuous-time Markov chains and chemical reaction networks.</p> Reference <pre><code>@article{gillespie1977exact,\n    title={Exact stochastic simulation of coupled chemical reactions},\n    author={Gillespie, Daniel T},\n    journal={The Journal of Physical Chemistry},\n    volume={81},\n    number={25},\n    pages={2340--2361},\n    year={1977},\n    publisher={ACS Publications}\n}\n</code></pre>"},{"location":"api/aggregators/#jumpax.SimpleTauLeaping","title":"<code>jumpax.SimpleTauLeaping(jumpax.AbstractAggregator)</code> <code></code>","text":"<p>Simple \\(\\tau\\)-leaping aggregator with fixed step size.</p> <p>At each step, draws reaction counts from Poisson distributions:</p> \\[K_j \\sim \\text{Poisson}(a_j(u) \\cdot \\tau)\\] <p>where \\(a_j(u)\\) is the propensity of reaction \\(j\\) and \\(\\tau\\) is the step size. The state is then updated by applying all reactions simultaneously.</p> <p>This is an approximate method that trades exactness for computational efficiency, particularly useful for systems with many reactions per unit time.</p> Reference <pre><code>@article{gillespie2001approximate,\n    title={Approximate accelerated stochastic simulation of chemically\n           reacting systems},\n    author={Gillespie, Daniel T},\n    journal={The Journal of Chemical Physics},\n    volume={115},\n    number={4},\n    pages={1716--1733},\n    year={2001},\n    publisher={AIP Publishing}\n}\n</code></pre>"},{"location":"api/aggregators/#hybrid-aggregators","title":"Hybrid Aggregators","text":"<p>Hybrid aggregators combine jump processes with continuous dynamics (ODEs/SDEs) using diffrax.</p>"},{"location":"api/aggregators/#jumpax.HybridSSA","title":"<code>jumpax.HybridSSA(jumpax.AbstractHybridAggregator)</code> <code></code>","text":"<p>Hybrid SSA + diffrax ODE integration for CRJ/MAJ with piecewise-constant rates.</p> <p>Assumptions:</p> <ul> <li>Jump rates do not depend on ODE-evolved components (constant between jumps).</li> <li><code>ode_fn(t, y, args)</code> returns dy with same shape as y.</li> <li>Only ODE is integrated between jumps; at a jump time we apply the discrete affect.</li> </ul>"},{"location":"api/aggregators/#jumpax.HybridSSA.__init__","title":"<code>__init__(ode_fn, *, solver: diffrax.AbstractSolver, dt0: Real[ArrayLike, ''] | None = None, stepsize_controller: diffrax.AbstractStepSizeController | None = None, ode_args: PyTree[Any] | None = None, max_steps: int | None = None)</code>","text":"<p>Arguments:</p> <ul> <li><code>ode_fn</code>: ODE drift function <code>f(t, u, args) -&gt; du/dt</code></li> <li><code>solver</code>: diffrax solver (e.g., <code>diffrax.Tsit5()</code>)</li> <li><code>dt0</code>: initial step size for diffrax</li> <li><code>stepsize_controller</code>: diffrax step size controller</li> <li><code>ode_args</code>: separate args for the ODE</li> <li><code>max_steps</code>: maximum diffrax steps per integration interval</li> </ul>"},{"location":"api/aggregators/#jumpax.HazardSSA","title":"<code>jumpax.HazardSSA(jumpax.AbstractHybridAggregator)</code> <code></code>","text":"<p>Hazard (time-change) SSA that supports ODE and SDEs.</p> <p>Uses the random time change representation: for each reaction channel \\(j\\), maintain an integrated hazard \\(A_j(t) = \\int_0^t \\lambda_j(s, u(s)) ds\\) and fire when \\(A_j\\) exceeds an exponential threshold \\(z_j\\).</p> <p>This allows coupling jump processes with continuous dynamics via diffrax.</p>"},{"location":"api/aggregators/#jumpax.HazardSSA.__init__","title":"<code>__init__(drift_fn: Callable | None, *, solver: diffrax.AbstractSolver, dt0: Real[ArrayLike, ''] | None = None, stepsize_controller: diffrax.AbstractStepSizeController | None = None, diffusion_fn: Callable | None = None, brownian_tol: Real[ArrayLike, ''] = 0.001, ode_args: PyTree[Any] | None = None, max_steps: int | None = None)</code>","text":"<p>Arguments:</p> <ul> <li><code>drift_fn</code>: drift function <code>f(t, u, args) -&gt; du/dt</code></li> <li><code>solver</code>: diffrax solver (e.g., <code>diffrax.Tsit5()</code>)</li> <li><code>dt0</code>: initial step size for diffrax</li> <li><code>stepsize_controller</code>: diffrax step size controller</li> <li><code>diffusion_fn</code>: SDE diffusion function <code>g(t, u, args)</code>, or None for ODE</li> <li><code>brownian_tol</code>: tolerance for virtual Brownian tree (SDE only)</li> <li><code>ode_args</code>: separate args for the ODE/SDE (defaults to jump args)</li> <li><code>max_steps</code>: maximum diffrax steps per integration interval</li> </ul>"},{"location":"api/cme/","title":"Chemical Master Equation","text":"<p>Exact Chemical Master Equation solver via matrix exponentiation.</p> <p>For time-independent reaction systems with finite (or finitely truncated) state spaces, the probability distribution \\(P(t)\\) evolves according to:</p> \\[\\frac{dP}{dt} = Q P\\] <p>where \\(Q\\) is the generator (rate) matrix. The exact solution is:</p> \\[P(t) = e^{Qt} P(0)\\] <p>This module provides utilities to:</p> <ol> <li>Build the generator matrix \\(Q\\) from a <code>MassActionJump</code> problem on a truncated state space</li> <li>Solve the CME exactly using matrix exponentiation</li> </ol>"},{"location":"api/cme/#functions","title":"Functions","text":""},{"location":"api/cme/#jumpax.build_generator","title":"<code>jumpax.build_generator(problem: jumpax.MassActionJump, max_counts: Int[Array, 'S'], *, args: PyTree[Any] = None, t0: float = 0.0) -&gt; tuple</code> <code></code>","text":"<p>Build the generator matrix Q for a <code>jumpax.MassActionJump</code> on a truncated state space.</p> <p>The state space is the rectangular lattice \\(\\{0, ..., \\text{max\\_counts}_i\\}\\) for each species \\(i\\). Transitions leaving this box are dropped.</p> <p>Arguments:</p> <ul> <li><code>problem</code>: A <code>jumpax.MassActionJump</code> defining the reaction system</li> <li><code>max_counts</code>: array of maximum population per species</li> <li><code>args</code>: Optional arguments passed to rate function</li> <li><code>t0</code>: Time at which to evaluate rates (only matters for time-dependent rates)</li> </ul> <p>Returns:</p> <ul> <li><code>Q</code>: generator matrix where N = prod(max_counts + 1)</li> <li><code>cme_state</code>: CMEState containing state space information</li> </ul>"},{"location":"api/cme/#jumpax.solve_cme","title":"<code>jumpax.solve_cme(Q: Float[Array, 'N N'], p0: Float[Array, 'N'], t: float) -&gt; Float[Array, 'N']</code> <code></code>","text":"<p>Solve the CME exactly via matrix exponentiation.</p> <p>Computes \\(P(t) = \\exp(Q t) P(0)\\).</p> <p>Arguments:</p> <ul> <li><code>Q</code>: generator matrix from <code>jumpax.build_generator</code></li> <li><code>p0</code>: initial probability distribution (should sum to 1)</li> <li><code>t</code>: Time at which to evaluate the distribution</li> </ul> <p>Returns:</p> <ul> <li><code>p_t</code>: probability distribution at time t</li> </ul>"},{"location":"api/cme/#jumpax.marginal_distribution","title":"<code>jumpax.marginal_distribution(p: Float[Array, 'N'], cme_state: jumpax.CMEState, species: int) -&gt; Float[Array, 'M']</code> <code></code>","text":"<p>Compute the marginal distribution for a single species.</p> <p>Arguments:</p> <ul> <li><code>p</code>: probability distribution over states</li> <li><code>cme_state</code>: State space information</li> <li><code>species</code>: Index of species to marginalize over</li> </ul> <p>Returns:</p> <ul> <li><code>marginal</code>: marginal distribution where M = max_counts[species] + 1</li> </ul>"},{"location":"api/cme/#types","title":"Types","text":""},{"location":"api/cme/#jumpax.CMEState","title":"<code>jumpax.CMEState</code> <code></code>","text":"<p>State space information for Chemical Master Equation (CME) solver.</p> <p>Attributes:</p> Name Type Description <code>states</code> <p>array of all states in the truncated state space</p> <code>strides</code> <p>array for mixed-radix encoding</p> <code>max_counts</code> <p>array of maximum count per species</p>"},{"location":"api/jumps/","title":"Jump Problems","text":"<p>Jump problems define the rates and effects of discrete jumps in the system.</p>"},{"location":"api/jumps/#abstract-base-classes","title":"Abstract Base Classes","text":""},{"location":"api/jumps/#jumpax.AbstractJumpProblem","title":"<code>jumpax.AbstractJumpProblem</code> <code></code>","text":"<p>Abstract class for general jump problems.</p>"},{"location":"api/jumps/#jumpax.AbstractJumpProblem.init","title":"<code>init(u: Shaped[Array, '?*u'], args: PyTree[Any], key: Key[Array, '']) -&gt; PyTree[Any]</code>","text":"<p>Initialize the state of the affect.</p> <p>Arguments:</p> <ul> <li><code>u</code>: the current state of the system</li> <li><code>args</code>: any static arguments as passed to <code>jumpax.solve</code></li> <li><code>key</code>: a random key to use</li> </ul> <p>Returns:</p> <p>The initialized state.</p>"},{"location":"api/jumps/#jumpax.AbstractJumpProblem.rate","title":"<code>rate(t: Real[ArrayLike, ''], u: Shaped[Array, '?*u'], args: PyTree[Any]) -&gt; ~_Rate</code>","text":"<p>Computes the rates of each possible reaction.</p> <p>Arguments:</p> <ul> <li><code>t</code>: current time</li> <li><code>u</code>: current state</li> <li><code>args</code>: static arguments</li> </ul> <p>Returns:</p> <p>The rates for each possible reaction.</p>"},{"location":"api/jumps/#jumpax.AbstractJumpProblem.affect","title":"<code>affect(t: Real[ArrayLike, ''], u: Shaped[Array, '?*u'], args: PyTree[Any], jump_state: PyTree[Any]) -&gt; tuple</code>","text":"<p>Compute the result of applying some affect.</p> <p>Arguments:</p> <ul> <li><code>t</code>: the time of the affect</li> <li><code>u</code>: the current state</li> <li><code>args</code>: any static arguments</li> <li><code>jump_state</code>: the state of the affect currently</li> </ul> <p>Results:</p> <p>The new state and the new affect state.</p>"},{"location":"api/jumps/#jumpax.AbstractJumpProblem.leap_delta","title":"<code>leap_delta(t: Real[ArrayLike, ''], u: Shaped[Array, '?*u'], args: PyTree[Any])</code>","text":"<p>Compute the per-reaction net state change.</p> <p>Arguments:</p> <ul> <li><code>t</code>: current time</li> <li><code>u</code>: current state</li> <li><code>args</code>: static arguments</li> </ul> <p>Returns:</p> <p>An array of shape <code>(R, S)</code> where <code>R</code> is the number of reactions and <code>S</code> is the number of species, representing the net state change for each reaction.</p>"},{"location":"api/jumps/#jumpax.AbstractAffect","title":"<code>jumpax.AbstractAffect</code> <code></code>","text":"<p>Abstract base class for all affects.</p>"},{"location":"api/jumps/#jumpax.AbstractAffect.init","title":"<code>init(u: Shaped[Array, '?*u'], args: PyTree[Any], key: Key[Array, '']) -&gt; ~_JumpState</code>","text":"<p>Initialize the state of the affect.</p> <p>Arguments:</p> <ul> <li><code>u</code>: the current state of the system</li> <li><code>args</code>: any static arguments as passed to <code>jumpax.solve</code></li> <li><code>key</code>: a random key to use</li> </ul> <p>Returns:</p> <p>The initialized state.</p>"},{"location":"api/jumps/#jumpax.AbstractAffect.__call__","title":"<code>__call__(t: Real[ArrayLike, ''], u: Shaped[Array, '?*u'], args: PyTree[Any], jump_state: ~_JumpState) -&gt; tuple</code>","text":"<p>Compute the result of applying the affect.</p> <p>Arguments:</p> <ul> <li><code>t</code>: the time of the affect</li> <li><code>u</code>: the current state</li> <li><code>args</code>: any static arguments</li> <li><code>jump_state</code>: the state of the affect currently</li> </ul> <p>Results:</p> <p>The new state and the new affect state.</p>"},{"location":"api/jumps/#jump-problem-types","title":"Jump Problem Types","text":""},{"location":"api/jumps/#jumpax.ConstantRateJump","title":"<code>jumpax.ConstantRateJump(jumpax.AbstractJumpProblem)</code> <code></code>","text":"<p>A jump process with a rate \\(\\lambda(u)\\) that depends only on the current state.</p> <p>The rate function is evaluated only at jump times, making this suitable for processes where the rate does not depend on continuously evolving dynamics between jumps.</p>"},{"location":"api/jumps/#jumpax.ConstantRateJump.__init__","title":"<code>__init__(rate_fn: Callable, affect_fn: jumpax.AbstractAffect)</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/jumps/#jumpax.MassActionJump","title":"<code>jumpax.MassActionJump(jumpax.AbstractJumpProblem)</code> <code></code>","text":"<p>Array-based mass-action reaction system.</p> <p>The propensity for reaction \\(j\\) is given by:</p> \\[a_j(u) = \\kappa_j \\prod_i \\binom{u_i}{r_{ji}}\\] <p>where \\(\\kappa_j\\) is the rate constant, \\(u_i\\) is the population of species \\(i\\), and \\(r_{ji}\\) is the stoichiometric coefficient of species \\(i\\) in reaction \\(j\\). The binomial coefficient \\(\\binom{n}{k} = 0\\) when \\(k &gt; n\\).</p>"},{"location":"api/jumps/#jumpax.MassActionJump.__init__","title":"<code>__init__(reactants: Int[Array, 'R S'], net_stoich: Int[Array, 'R S'], *, rates: Float[Array, 'R'])</code>","text":"<p>Arguments:</p> <ul> <li><code>reactants</code>: int array \\((R, S)\\) with nonnegative stoichiometry for each     reaction \\(j\\) and species \\(i\\).</li> <li><code>net_stoich</code>: int array \\((R, S)\\) with net state change per reaction.</li> <li><code>rates</code>: float array \\((R,)\\) of rate constants \\(\\kappa_j\\).</li> </ul>"},{"location":"api/jumps/#jumpax.VariableRateJump","title":"<code>jumpax.VariableRateJump(jumpax.AbstractJumpProblem)</code> <code></code>","text":"<p>A jump process with a rate \\(\\lambda(t, u)\\) that depends on time and state.</p> <p>Unlike <code>jumpax.ConstantRateJump</code>, the rate is evaluated continuously during integration, making this suitable for processes coupled to ODEs or other continuously evolving dynamics.</p>"},{"location":"api/jumps/#jumpax.VariableRateJump.__init__","title":"<code>__init__(rate_fn: Callable, affect_fn: jumpax.AbstractAffect, leap_delta_fn: Callable | None = None)</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"api/jumps/#jumpax.StatelessAffect","title":"<code>jumpax.StatelessAffect(jumpax.AbstractAffect)</code> <code></code>","text":"<p>A convenience wrapper for the common use case of stateless affect functions.</p>"},{"location":"api/save/","title":"Save","text":""},{"location":"api/save/#jumpax.Save","title":"<code>jumpax.Save</code> <code></code>","text":"<p>Controls what data to save during simulation.</p>"},{"location":"api/save/#jumpax.Save.__init__","title":"<code>__init__(states: bool = True, reaction_counts: bool = False, dense: bool = False)</code>","text":"<p>Arguments:</p> <ul> <li><code>states</code>: Whether to save the state at each step of the solver. Defaults to <code>True</code>.</li> <li><code>reaction_counts</code>: Whether to save an array containing the number of times each     reaction occurred. Defaults to <code>False</code>.</li> <li><code>dense</code>: Whether to save the intermediate diffrax solver steps in hybrid models.     Only applicable when using <code>jumpax.HybridSSA</code> or <code>jumpax.HazardSSA</code>.     Defaults to <code>False</code>.</li> </ul>"},{"location":"api/solution/","title":"Solution","text":""},{"location":"api/solution/#jumpax.Solution","title":"<code>jumpax.Solution</code> <code></code>","text":"<p>A module containing all possible solution information.</p> <ul> <li><code>ts</code>: is the times at which states where recorded (if the     states were recorded)</li> <li><code>us</code>: the states logged</li> <li><code>counts</code>: optionally the reaction counts for each possible reaction</li> <li><code>stats</code>: information on the solution finding process</li> <li><code>dense</code>: optionally a dict with <code>dense_ts</code> and <code>dense_us</code> from the diffrax solver</li> </ul>"},{"location":"api/solve/","title":"solve","text":""},{"location":"api/solve/#jumpax.solve","title":"<code>jumpax.solve(jumps: jumpax.AbstractJumpProblem, solver: jumpax.AbstractAggregator, save: jumpax.Save, u0: Shaped[Array, '?*u'], *, t0: Real[ArrayLike, ''], t1: Real[ArrayLike, ''], key: Key[Array, ''], args: PyTree[Any] = None, max_steps: int = 4096) -&gt; jumpax.Solution</code> <code></code>","text":"<p>Simulate a jump process from <code>t0</code> to <code>t1</code>.</p> <p>Arguments:</p> <ul> <li><code>jumps</code>: the jump problem to solve</li> <li><code>solver</code>: the aggregator/solver to use (e.g., <code>jumpax.SSA</code>)</li> <li><code>save</code>: controls what to save (states, counts, dense output)</li> <li><code>u0</code>: initial state</li> <li><code>t0</code>: start time</li> <li><code>t1</code>: end time</li> <li><code>key</code>: JAX random key</li> <li><code>args</code>: static arguments passed to rate and affect functions</li> <li><code>max_steps</code>: maximum number of solver steps before termination</li> </ul> <p>Returns:</p> <p>A <code>jumpax.Solution</code> containing saved times, states, and statistics.</p>"},{"location":"examples/01_poisson_process/","title":"Simple Poisson Processes","text":"<p>Jumpax simulates jump processes where the transition rate (intensity/propensity) can depend on the current state <code>u</code>, parameters <code>p</code>, and time <code>t</code>. When a jump occurs, we apply an update (affect) to the state.</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport jumpax as jx\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"examples/01_poisson_process/#constant-rate-jumps","title":"Constant Rate Jumps","text":"<p>We simulate a Poisson counting process with constant rate <code>\u03bb</code>.</p> <ul> <li><code>rate(t, u, p)</code> returns <code>p[\"lam\"]</code> (constant intensity).</li> <li><code>affect(...)</code> increments <code>u[0]</code> by 1 at each jump.</li> </ul> <pre><code>rate = lambda t, u, p: jnp.array([p[\"lam\"]])\n\naffect = jx.StatelessAffect(lambda t, u, p: jnp.expand_dims(u.at[0].add(1), axis=0))\n\ncrj = jx.ConstantRateJump(rate, affect)\n\nu0 = jnp.array([0])\np = {\"lam\": 2.0}\nt0, t1 = 0.0, 10.0\nkey = jax.random.key(0)\n\nsolver = jx.SSA()\nsave = jx.Save(states=True, reaction_counts=True)\nsol = jx.solve(crj, solver, save, u0, t0=t0, t1=t1, args=p, key=key)\n\nmask = jnp.isfinite(sol.ts)\nts = sol.ts[mask]\nus = sol.us[mask]\n\nplt.figure()\nplt.step(ts, us[:, 0], where=\"post\", label=\"N(t)\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"lower right\")\nplt.show()\n</code></pre> <p></p> <p>Add a death process with rate <code>\u03bc * u[0]</code>, and track total deaths in <code>u[1]</code>.</p> <pre><code>rate = lambda t, u, p: jnp.array([p[\"lam\"], p[\"mu\"] * u[0]])\n\n\ndef _affect_bd(t, u, p):\n    u_birth = u.at[0].add(1)\n    u_death = u.at[0].add(-1)\n    u_death = u_death.at[1].add(1)\n    return jnp.stack((u_birth, u_death))\n\n\naffect = jx.StatelessAffect(_affect_bd)\ncrj = jx.ConstantRateJump(rate, affect)\n\nu0 = jnp.array([0, 0])\np = {\"lam\": 2.0, \"mu\": 1.5}\nt0, t1 = 0.0, 10.0\nkey = jax.random.key(1)\n\nsolver = jx.SSA()\nsave = jx.Save(states=True, reaction_counts=True)\nsol = jx.solve(crj, solver, save, u0, t0=t0, t1=t1, args=p, key=key)\n\nmask = jnp.isfinite(sol.ts)\nts = sol.ts[mask]\nus = sol.us[mask]\n\nplt.figure()\nplt.step(ts, us[:, 0], where=\"post\", label=\"N(t)\")\nplt.step(ts, us[:, 1], where=\"post\", label=\"D(t)\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.show()\n</code></pre> <p></p> <p>Simulate a compound Poisson process with random jumps \\(C_i \\in \\{-1,1\\}\\). Keep \\(N(t)=u[0]\\) and \\(G(t)=u[1]\\). The randomness lives in an <code>aggregator_state</code> carrying a key.</p> <pre><code>rate3 = lambda t, u, p: jnp.array([p[\"lam\"]])\n\n\nclass Affect3(jx.AbstractAffect):\n    def init(self, u, args, key):\n        return key\n\n    def __call__(self, t, u, p, aggregator_state):\n        key = aggregator_state\n        key, sub = jax.random.split(key)\n        step = jax.random.choice(sub, jnp.array([-1, 1], dtype=u.dtype))\n        u_new = u.at[0].add(1)\n        u_new = u_new.at[1].add(step)\n        return jnp.expand_dims(u_new, axis=0), key\n\n\naffect3 = Affect3()\ncrj = jx.ConstantRateJump(rate3, affect3)\n\nu0 = jnp.array([0, 0])\np = {\"lam\": 1.0}\nt0, t1 = 0.0, 100.0\nkey = jax.random.key(0)\n\nsolver = jx.SSA()\nsave = jx.Save(states=True, reaction_counts=True)\nsol = jx.solve(crj, solver, save, u0, t0=t0, t1=t1, args=p, key=key)\n\nmask = jnp.isfinite(sol.ts)\nts = sol.ts[mask]\nus = sol.us[mask]\n\nplt.figure()\nplt.step(ts, us[:, 0], where=\"post\", label=\"N(t)\")\nplt.step(ts, us[:, 1], where=\"post\", label=\"G(t)\")\nplt.xlabel(\"t\")\nplt.legend(loc=\"upper left\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/02_continuous_time_gillespie_methods/","title":"Continuous-Time Jump Processes and Gillespie Methods (SIR)","text":"<pre><code>import jax\nimport jax.numpy as jnp\nimport jumpax as jx\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"examples/02_continuous_time_gillespie_methods/#sir-via-constantratejump","title":"SIR via ConstantRateJump","text":"<p>Rates: [beta * S * I, nu * I]. Affects: infection and recovery.</p> <pre><code>beta, nu = 0.1 / 1000.0, 0.01\nrate = lambda t, u, p: jnp.array([p[\"beta\"] * u[0] * u[1], p[\"nu\"] * u[1]])\n\n\ndef _affect_sir(t, u, p):\n    # infection: S -= 1, I += 1\n    u_inf = u.at[0].add(-1)\n    u_inf = u_inf.at[1].add(1)\n    # recovery: I -= 1, R += 1\n    u_rec = u.at[1].add(-1)\n    u_rec = u_rec.at[2].add(1)\n    return jnp.stack((u_inf, u_rec))\n\n\naffect = jx.StatelessAffect(_affect_sir)\ncrj = jx.ConstantRateJump(rate, affect)\n\nu0 = jnp.array([990, 10, 0])\np = {\"beta\": beta, \"nu\": nu}\nt0, t1 = 0.0, 250.0\nkey = jax.random.key(0)\n\nsolver = jx.SSA()\nsave = jx.Save(states=True, reaction_counts=True)\nsol_crj = jx.solve(crj, solver, save, u0, t0=t0, t1=t1, args=p, key=key)\n\nmask = jnp.isfinite(sol_crj.ts)\nts = sol_crj.ts[mask]\nus = sol_crj.us[mask]\n\nplt.figure()\nplt.step(ts, us[:, 0], label=\"S(t)\")\nplt.step(ts, us[:, 1], label=\"I(t)\")\nplt.step(ts, us[:, 2], label=\"R(t)\")\nplt.xlabel(\"t\")\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/02_continuous_time_gillespie_methods/#sir-via-massactionjump","title":"SIR via MassActionJump","text":"<pre><code># Reactions in array form (reactions x species)\nreactant_stoich = jnp.array(\n    [\n        [1, 1, 0],  # S + I\n        [0, 1, 0],  # I\n    ]\n)\nnet_stoich = jnp.array(\n    [\n        [-1, 1, 0],  # -S + I\n        [0, -1, 1],  # -I + R\n    ]\n)\nmaj = jx.MassActionJump(reactant_stoich, net_stoich, rates=jnp.array([beta, nu]))\n\nkey2 = jax.random.key(1)\nsol_maj = jx.solve(maj, solver, save, u0, t0=t0, t1=t1, args=p, key=key2)\n\nmask2 = jnp.isfinite(sol_maj.ts)\nts2 = sol_maj.ts[mask2]\nus2 = sol_maj.us[mask2]\n\nplt.figure()\nplt.step(ts2, us2[:, 0], label=\"S(t)\")\nplt.step(ts2, us2[:, 1], label=\"I(t)\")\nplt.step(ts2, us2[:, 2], label=\"R(t)\")\nplt.xlabel(\"t\")\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"examples/02_continuous_time_gillespie_methods/#-leaping-with-massactionjump","title":"\u03c4-leaping with MassActionJump","text":"<pre><code>dt = 1.0\nleaper = jx.SimpleTauLeaping(dt)\nkey4 = jax.random.key(3)\nsol_tau_maj = jx.solve(maj, leaper, save, u0, t0=t0, t1=t1, args=None, key=key4)\nmask4 = jnp.isfinite(sol_tau_maj.ts)\nts4 = sol_tau_maj.ts[mask4]\nus4 = sol_tau_maj.us[mask4]\nplt.figure()\nplt.step(ts4, us4[:, 0], label=\"S(t)\")\nplt.step(ts4, us4[:, 1], label=\"I(t)\")\nplt.step(ts4, us4[:, 2], label=\"R(t)\")\nplt.xlabel(\"t\")\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"examples/02_continuous_time_gillespie_methods/#hybrid-ode-ssa","title":"Hybrid ODE + SSA","text":"<p>ODE evolves u[3]; jumps affect u[0:3]. Rates do not depend on u[3].</p> <pre><code>import diffrax as dfx\n\n\ndef f(t, y, args):\n    # dy[3] = y[1] * y[2] / 1e5 - y[0] * y[3] / 1e5\n    dy = jnp.zeros_like(y)\n    dy = dy.at[3].set(y[1] * y[2] / 1e5 - y[0] * y[3] / 1e5)\n    return dy\n\n\nu0_h = jnp.array([990.0, 10.0, 0.0, 100.0])\nbeta, nu = 0.1 / 1000.0, 0.01\nrate_h = lambda t, u, p: jnp.array([p[\"beta\"] * u[0] * u[1], p[\"nu\"] * u[1]])\n\n\ndef _affect_sir(t, u, p):\n    u_inf = u.at[0].add(-1)\n    u_inf = u_inf.at[1].add(1)\n    u_rec = u.at[1].add(-1)\n    u_rec = u_rec.at[2].add(1)\n    return jnp.stack((u_inf, u_rec))\n\n\naffect_h = jx.StatelessAffect(_affect_sir)\ncrj_h = jx.ConstantRateJump(rate_h, affect_h)\np_h = {\"beta\": beta, \"nu\": nu}\n\nhyb = jx.HybridSSA(f, solver=dfx.Tsit5(), dt0=1e-1)\nkey6 = jax.random.key(5)\nsave = jx.Save(states=True, reaction_counts=True)\nsol_h = jx.solve(crj_h, hyb, save, u0_h, t0=0.0, t1=250.0, args=p_h, key=key6)\n\nmaskh = jnp.isfinite(sol_h.ts)\ntsh = sol_h.ts[maskh]\nush = sol_h.us[maskh]\n\nplt.figure()\nplt.step(tsh, ush[:, 0], label=\"S(t)\")\nplt.step(tsh, ush[:, 1], label=\"I(t)\")\nplt.step(tsh, ush[:, 2], label=\"R(t)\")\nplt.step(tsh, ush[:, 3], label=\"u3(t)\")\nplt.xlabel(\"t\")\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/02_continuous_time_gillespie_methods/#general-variable-rate-jump","title":"General Variable-Rate Jump","text":"<p>Add a reaction with rate 1e-2 * u[3] that increases I by 1. Rates depend on ODE-evolved u[3].</p> <pre><code>rate_v = lambda t, u, p: jnp.array(\n    [p[\"beta\"] * u[0] * u[1], p[\"nu\"] * u[1], 1e-2 * u[3]]\n)\n\n\ndef _affect_sir_var(t, u, p):\n    # infection\n    u_inf = u.at[0].add(-1)\n    u_inf = u_inf.at[1].add(1)\n    # recovery\n    u_rec = u.at[1].add(-1)\n    u_rec = u_rec.at[2].add(1)\n    # variable-rate: I += 1\n    u_var = u.at[1].add(1)\n    return jnp.stack((u_inf, u_rec, u_var))\n\n\ncrj_v = jx.ConstantRateJump(rate_v, jx.StatelessAffect(_affect_sir_var))\nhaz = jx.HazardSSA(\n    f, solver=dfx.Tsit5(), dt0=1e-1\n)  # , stepsize_controller=dfx.PIDController(rtol=1e-5, atol=1e-7))\nu0_v = jnp.array([990.0, 10.0, 0.0, 100.0])\nkey7 = jax.random.key(6)\nsol_v = jx.solve(crj_v, haz, save, u0_v, t0=0.0, t1=250.0, args=p_h, key=key7)\n\nmaskv = jnp.isfinite(sol_v.ts)\ntsv = sol_v.ts[maskv]\nusv = sol_v.us[maskv]\n\nplt.figure()\nplt.step(tsv, usv[:, 0], label=\"S(t)\")\nplt.step(tsv, usv[:, 1], label=\"I(t)\")\nplt.step(tsv, usv[:, 2], label=\"R(t)\")\nplt.step(tsv, usv[:, 3], label=\"u3(t)\")\nplt.xlabel(\"t\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <pre><code>print(sol_v.stats[\"num_steps\"])\nprint(sol_v.counts)\nprint(jnp.diff(sol_v.ts[jnp.isfinite(sol_v.ts)])[:20])\nprint(sol_h.stats[\"num_steps\"])\nprint(sol_h.counts)\n</code></pre> <pre><code>3088\n[ 990 1264  833]\n[0.51814586 0.02698904 0.10867316 0.03910464 0.16283113 1.3336401\n 0.45395732 0.658875   0.7667401  0.33237362 0.02027369 0.03518486\n 0.8102646  0.04348278 0.0493474  0.02558041 0.04307079 0.07930756\n 0.11707258 0.05244255]\n1867\n[990 876]\n</code></pre>"},{"location":"examples/03_jump_diffusion/","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"<pre><code>import diffrax as dfx\nimport jax\nimport jax.numpy as jnp\nimport jumpax as jx\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <pre><code>def plot_solution(sol):\n    # First, get the jump points\n    mask = jnp.isfinite(sol.ts)\n    jump_ts = np.array(sol.ts[mask], dtype=float)\n    jump_us = np.array(sol.us[mask, 0], dtype=float)\n\n    plt.figure()\n\n    dense_ts_all = sol.dense[\"dense_ts\"]\n    dense_us_all = sol.dense[\"dense_us\"]\n\n    full_ts = []\n    full_us = []\n\n    # Process each segment between jumps\n    for i in range(dense_ts_all.shape[0]):\n        segment_ts = dense_ts_all[i]\n        segment_us = dense_us_all[i].squeeze()\n\n        # Filter out inf values\n        valid_mask = np.isfinite(segment_ts)\n        if np.any(valid_mask):\n            t_seg = np.array(segment_ts[valid_mask], dtype=float)\n            u_seg = segment_us[valid_mask]\n            u_seg = np.array(u_seg, dtype=float)\n\n            full_ts.extend(t_seg)\n            full_us.extend(u_seg)\n\n            if i &lt; len(jump_ts) - 2:\n                jump_time = t_seg[-1]\n                post_jump_value = jump_us[i + 1]\n                full_ts.append(jump_time)\n                full_us.append(post_jump_value)\n\n    if full_ts:\n        plt.plot(full_ts, full_us, \"b-\", linewidth=1.0, label=\"Trajectory\")\n\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"State\")\n    plt.legend(loc=\"best\")\n    plt.grid(True, alpha=0.3)\n    plt.show()\n\n    return jump_ts, jump_us\n</code></pre> <pre><code>t0, t1 = 0.0, 10.0\nu0 = jnp.array([0.2])\nsave_dense = jx.Save(states=True, reaction_counts=True, dense=True)\n\n\ndef ode_fn(t, y, args):\n    # Exponential growth between jumps\n    return y\n\n\ndef halving_affect(t, u, args):\n    halved = u.at[0].set(0.5 * u[0])\n    return jnp.stack([halved], axis=0)\n\n\nhalve_affect = jx.StatelessAffect(halving_affect)\n</code></pre>"},{"location":"examples/03_jump_diffusion/#constant-rate-jump","title":"Constant-Rate Jump","text":"<pre><code>rate_const = lambda t, u, args: jnp.array([2.0])\nconst_jump = jx.ConstantRateJump(rate_const, halve_affect)\n\nhybrid_solver = jx.HybridSSA(ode_fn, solver=dfx.Tsit5(), dt0=1e-2, max_steps=1000)\nsol_const = jx.solve(\n    const_jump,\n    hybrid_solver,\n    save_dense,\n    u0,\n    t0=t0,\n    t1=t1,\n    args=None,\n    key=jax.random.key(0),\n)\n\nplot_solution(sol_const)\nprint(\"Reaction counts:\", sol_const.counts)\nprint(\"Steps taken:\", sol_const.stats[\"num_steps\"].item())\n</code></pre> <pre><code>Reaction counts: [24]\nSteps taken: 25\n</code></pre>"},{"location":"examples/03_jump_diffusion/#variable-rate-jump","title":"Variable-Rate Jump","text":"<p>Now the rate equals the current state value. The rate evolves continuously, so we switch to <code>HazardSSA</code>, which integrates the hazard function alongside the ODE using Diffrax.</p> <pre><code>rate_var = lambda t, u, args: jnp.array([u[0]])\nvar_jump = jx.VariableRateJump(rate_var, halve_affect)\n\nhazard_solver = jx.HazardSSA(ode_fn, solver=dfx.Tsit5(), dt0=1e-2, max_steps=1000)\nsol_var = jx.solve(\n    var_jump,\n    hazard_solver,\n    save_dense,\n    u0,\n    t0=t0,\n    t1=t1,\n    args=None,\n    key=jax.random.key(0),\n)\n\nplot_solution(sol_var)\nprint(\"Reaction counts:\", sol_var.counts)\nprint(\"Steps taken:\", sol_var.stats[\"num_steps\"].item())\n</code></pre> <p></p> <pre><code>Reaction counts: [13]\nSteps taken: 14\n</code></pre>"},{"location":"examples/03_jump_diffusion/#multiple-jumps","title":"Multiple Jumps","text":"<p>We mix the constant and variable channels by stacking their rates and affects into a single <code>VariableRateJump</code>. Each jump channel halves the state.</p> <pre><code>def rate_multi(t, u, args):\n    return jnp.array([2.0, u[0]])\n\n\ndef affect_multi(t, u, args):\n    halved = u.at[0].set(0.5 * u[0])\n    return jnp.stack([halved, halved], axis=0)\n\n\nmulti_jump = jx.VariableRateJump(rate_multi, jx.StatelessAffect(affect_multi))\n\nhazard_multi_solver = jx.HazardSSA(ode_fn, solver=dfx.Tsit5(), dt0=1e-2, max_steps=1000)\nsol_multi = jx.solve(\n    multi_jump,\n    hazard_multi_solver,\n    save_dense,\n    u0,\n    t0=t0,\n    t1=t1,\n    args=None,\n    key=jax.random.key(4),\n)\n\nplot_solution(sol_multi)\nprint(\"Reaction counts:\", sol_multi.counts)\nprint(\"Steps taken:\", sol_multi.stats[\"num_steps\"].item())\n</code></pre> <p></p> <pre><code>Reaction counts: [16  3]\nSteps taken: 20\n</code></pre>"},{"location":"examples/03_jump_diffusion/#jump-diffusion","title":"Jump Diffusion","text":"<p>Finally we add multiplicative noise.</p> <pre><code>def drift(t, y, args):\n    return y\n\n\ndef diffusion(t, y, args):\n    return y[:, None]\n\n\nhazard_sde = jx.HazardSSA(\n    drift, solver=dfx.EulerHeun(), dt0=1e-3, diffusion_fn=diffusion, max_steps=1000\n)\n\nkey = jax.random.key(42)\nsol_diff = jx.solve(\n    multi_jump,\n    hazard_sde,\n    save_dense,\n    u0,\n    t0=t0,\n    t1=t1,\n    args=None,\n    key=key,\n)\n\nplot_solution(sol_diff)\nprint(\"Reaction counts:\", sol_diff.counts)\nprint(\"Steps taken:\", sol_diff.stats[\"num_steps\"].item())\n</code></pre> <p></p> <pre><code>Reaction counts: [26  1]\nSteps taken: 28\n</code></pre>"},{"location":"examples/04_exact_cme_solver/","title":"Exact Chemical Master Equation Solver","text":"<p>For finite state spaces, the Chemical Master Equation can be solved exactly via matrix exponentiation:</p> \\[P(t) = e^{Qt} P(0)\\] <p>where \\(Q\\) is the generator (rate) matrix. This gives the exact probability distribution over states, which we can compare to stochastic simulations.</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport jumpax as jx\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n</code></pre>"},{"location":"examples/04_exact_cme_solver/#birth-death-process","title":"Birth-Death Process","text":"<p>Consider a simple birth-death process with:</p> <ul> <li> <p>Birth: \\(\\emptyset \\xrightarrow{\\lambda} X\\) with rate \\(\\lambda\\)</p> </li> <li> <p>Death: \\(X \\xrightarrow{\\mu} \\emptyset\\) with rate \\(\\mu \\cdot n\\)</p> </li> </ul> <p>where \\(n\\) is the current population.</p> <pre><code>lam, mu = 5.0, 0.5\n\n# Reactants: birth needs nothing (0), death needs 1 particle\n# Net change: birth +1, death -1\nreactants = jnp.array([[0], [1]])\nnet_stoich = jnp.array([[1], [-1]])\nrates = jnp.array([lam, mu])\n\nproblem = jx.MassActionJump(reactants, net_stoich, rates=rates)\n</code></pre>"},{"location":"examples/04_exact_cme_solver/#build-generator-matrix","title":"Build Generator Matrix","text":"<p>We truncate the state space to \\(n \\in \\{0, 1, ..., N_{max}\\}\\) and build the generator matrix.</p> <pre><code>max_counts = jnp.array([50])\n\nQ, cme_state = jx.build_generator(problem, max_counts)\n\nprint(f\"State space size: {Q.shape[0]}\")\nprint(f\"States shape: {cme_state.states.shape}\")\nprint(f\"Q matrix shape: {Q.shape}\")\n</code></pre> <pre><code>State space size: 51\nStates shape: (51, 1)\nQ matrix shape: (51, 51)\n</code></pre> <pre><code>plt.figure(figsize=(5, 4))\nplt.imshow(Q, cmap=\"magma\", vmin=-15, vmax=15)\nplt.colorbar(label=\"Rate\")\nplt.xlabel(\"To state\")\nplt.ylabel(\"From state\")\nplt.title(\"Generator matrix Q\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/04_exact_cme_solver/#solve-the-cme","title":"Solve the CME","text":"<p>Starting from \\(n=0\\), compute the probability distribution at various times.</p> <pre><code># Initial distribution: start at n=0 with probability 1\np0 = jnp.zeros(Q.shape[0])\np0 = p0.at[0].set(1.0)\n\ntimes = jnp.array([0.5, 1.0, 2.0, 5.0, 10.0])\ndistributions = jax.jit(jax.vmap(lambda t: jx.solve_cme(Q, p0, t)))(times)\n</code></pre> <pre><code>plt.figure(figsize=(10, 6))\ncolors = cm.viridis(jnp.linspace(0, 1, len(times)))\n\nfor i, (t, p) in enumerate(zip(times, distributions)):\n    states = cme_state.states[:, 0]\n    plt.bar(states, p, alpha=0.6, label=f\"t={t:.1f}\", color=colors[i], width=0.8)\n\nplt.xlim(-1, 30)\nplt.xlabel(\"Population n\")\nplt.ylabel(\"P(n, t)\")\nplt.title(\"Exact probability distribution evolution\")\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/04_exact_cme_solver/#compare-to-ssa-simulations","title":"Compare to SSA Simulations","text":"<pre><code>n_samples = 2000\nt_final = 5.0\n\n\n@jax.jit\n@jax.vmap\ndef run_ssa(key):\n    sol = jx.solve(\n        problem,\n        jx.SSA(),\n        jx.Save(states=True),\n        jnp.array([0]),\n        t0=0.0,\n        t1=t_final,\n        args=None,\n        key=key,\n    )\n    final_idx = sol.stats[\"num_steps\"] - 1\n    return sol.us[final_idx, 0]\n\n\nkey = jax.random.key(0)\nfinal_states = run_ssa(jax.random.split(key, n_samples))\n</code></pre> <pre><code>p_exact = jx.solve_cme(Q, p0, t_final)\n\nmax_n = 30\nbins = jnp.arange(max_n + 2) - 0.5\nhist, _ = jnp.histogram(final_states, bins=bins, density=True)\n\nplt.figure(figsize=(10, 6))\nplt.bar(jnp.arange(max_n + 1), hist, alpha=0.6, label=\"SSA\", width=0.8)\nplt.plot(\n    jnp.arange(max_n + 1), p_exact[: max_n + 1], \"ko-\", label=\"Exact CME\", markersize=4\n)\nplt.xlabel(\"Population n\")\nplt.ylabel(\"P(n)\")\nplt.title(f\"Distribution at t={t_final}: Exact vs SSA\")\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"examples/04_exact_cme_solver/#two-species-simple-gene-expression","title":"Two-Species: Simple Gene Expression","text":"<p>(claude suggested this idea, so I apologize to any biologists if this is woefully incorrect)</p> <p>Model with mRNA (M) and protein (P):</p> <ul> <li> <p>Transcription: \\(\\emptyset \\xrightarrow{k_m} M\\)</p> </li> <li> <p>Translation: \\(M \\xrightarrow{k_p} M + P\\)</p> </li> <li> <p>mRNA decay: \\(M \\xrightarrow{\\gamma_m} \\emptyset\\)</p> </li> <li> <p>Protein decay: \\(P \\xrightarrow{\\gamma_p} \\emptyset\\)</p> </li> </ul> <pre><code>k_m, k_p = 2.0, 5.0  # transcription, translation rates\ngamma_m, gamma_p = 1.0, 0.5  # decay rates\n\n# Reactions:\n#   1. transcription: 0 -&gt; M\n#   2. translation:   M -&gt; M + P (M catalyzes P production)\n#   3. mRNA decay:    M -&gt; 0\n#   4. protein decay: P -&gt; 0\n\nreactants_gene = jnp.array(\n    [\n        [0, 0],  # transcription: needs nothing\n        [1, 0],  # translation: needs 1 M\n        [1, 0],  # mRNA decay: needs 1 M\n        [0, 1],  # protein decay: needs 1 P\n    ]\n)\n\nnet_stoich_gene = jnp.array(\n    [\n        [1, 0],  # transcription: +1 M\n        [0, 1],  # translation: +1 P (M unchanged)\n        [-1, 0],  # mRNA decay: -1 M\n        [0, -1],  # protein decay: -1 P\n    ]\n)\n\nrates_gene = jnp.array([k_m, k_p, gamma_m, gamma_p])\n\ngene_problem = jx.MassActionJump(reactants_gene, net_stoich_gene, rates=rates_gene)\n</code></pre> <pre><code>max_counts_gene = jnp.array([8, 40])\nQ_gene, cme_gene = jx.build_generator(gene_problem, max_counts_gene)\n\nprint(\n    f\"State space size: {Q_gene.shape[0]} ({max_counts_gene[0]} x {max_counts_gene[1]})\"\n)\n</code></pre> <pre><code>State space size: 369 (8 x 40)\n</code></pre> <pre><code># Initial distribution: M=0, P=0\np0_gene = jnp.zeros(Q_gene.shape[0])\np0_gene = p0_gene.at[0].set(1.0)\n\n# Solve at steady state\nt_ss = 20.0\np_ss = jax.jit(jx.solve_cme)(Q_gene, p0_gene, t_ss)\n</code></pre> <pre><code>n_m = max_counts_gene[0] + 1\nn_p = max_counts_gene[1] + 1\np_2d = p_ss.reshape(n_m, n_p)\n\nplt.figure(figsize=(6, 4))\nplt.imshow(p_2d.T, origin=\"lower\", aspect=\"auto\", cmap=\"magma\")\nplt.colorbar(label=\"P(M, P)\")\nplt.xlabel(\"mRNA count M\")\nplt.ylabel(\"Protein count P\")\nplt.title(f\"Joint steady-state distribution (t={t_ss})\")\nplt.show()\n</code></pre> <p></p> <pre><code>p_m = jx.marginal_distribution(p_ss, cme_gene, species=0)\np_p = jx.marginal_distribution(p_ss, cme_gene, species=1)\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 4))\n\naxes[0].bar(jnp.arange(n_m), p_m, color=\"steelblue\")\naxes[0].set_xlabel(\"mRNA count M\")\naxes[0].set_ylabel(\"P(M)\")\naxes[0].set_title(\"mRNA marginal distribution\")\n\naxes[1].bar(jnp.arange(n_p), p_p, color=\"coral\")\naxes[1].set_xlabel(\"Protein count P\")\naxes[1].set_ylabel(\"P(P)\")\naxes[1].set_title(\"Protein marginal distribution\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/04_exact_cme_solver/#time-evolution-of-means","title":"Time Evolution of Means","text":"<p>Track how expected counts evolve over time.</p> <pre><code>ts_gene = jnp.linspace(0, 20, 50)\nps_gene = jax.vmap(lambda t: jx.solve_cme(Q_gene, p0_gene, t))(ts_gene)\n\n\n# Compute expected values E[M] and E[P] at each time\ndef expected_counts(p):\n    return jnp.sum(p[:, None] * cme_gene.states, axis=0)\n\n\nmeans = jax.jit(jax.vmap(expected_counts))(ps_gene)\n\nplt.figure(figsize=(7, 4))\nplt.plot(ts_gene, means[:, 0], \"b-\", linewidth=2, label=\"E[mRNA]\")\nplt.plot(ts_gene, means[:, 1], \"r-\", linewidth=2, label=\"E[protein]\")\n\n# Analytical steady states for comparison\nm_ss = k_m / gamma_m\np_ss_analytical = k_m * k_p / (gamma_m * gamma_p)\nplt.axhline(m_ss, color=\"b\", linestyle=\"--\", alpha=0.5, label=\"M steady state\")\nplt.axhline(\n    p_ss_analytical, color=\"r\", linestyle=\"--\", alpha=0.5, label=\"P steady state\"\n)\n\nplt.xlabel(\"Time t\")\nplt.ylabel(\"Expected count\")\nplt.title(\"Expected counts over time (exact CME)\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"}]}